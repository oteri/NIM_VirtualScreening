<template>
  <form @submit.prevent="onSubmit">
    <FormField v-if="props.receptor!==undefined" name="smileString">
      <FormItem class="flex items-center w-full">
        <FormLabel class="w-1/6">SMILES String</FormLabel>
        <FormControl class="w-5/6">
          <Input type="text" placeholder="SMILES string used as input for molmim-generate" v-model="smileString" />
          <FormMessage v-if="smileStringError">{{ smileStringError }}</FormMessage>
          <Button type="submit">Generate Ligands</Button>
        </FormControl>
      </FormItem>
    </FormField>

    <Card v-if='molecules.length>0' class="border-top-1 xl:col-span-2 mt-6">
      <CardHeader class="flex flex-row items-center">
        <div class="w-1/6 grid gap-2">
          <CardTitle>Ligands</CardTitle>
          <CardDescription>
            Ligands generated by MolMim
          </CardDescription>
        </div>
        <div class="w-4/6 grid gap-2"></div>
        <Button class="w-1/6" type="button" @click="handleRunDiffDock">Run DiffDock</Button>
      </CardHeader>

      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead v-if="complexes && complexes.length>0">Download</TableHead>
              <TableHead>SMILES</TableHead>
              <TableHead class="text-right">Score</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            <TableRow v-for="(molecule, index) in paginatedMolecules" :key="index">
              <TableCell v-if="complexes && complexes.length>0">
                <Button type="button" @click="handleLigandDownload(index)">
                  <i v-if="!complexes[computeGlobalIndex(index)].error" class="fas fa-download" aria-hidden="true"></i>
                  <i v-else class="fas fa-exclamation-triangle" aria-hidden="true" style="color: red;"></i>
                </Button>
              </TableCell>
              <TableCell>{{ molecule.sample }}</TableCell>
              <TableCell class="text-right">{{ molecule.score }}</TableCell>
            </TableRow>
          </TableBody>
        </Table>

      </CardContent>

      <CardFooter class="flex flex-row items-center border-t bg-muted/50 px-6 py-3">
        <div class="text-xs text-muted-foreground">
          Page {{currentPage +1}} of {{ pageCount }}
        </div>
        <Pagination class="ml-auto mr-0 w-auto">
          <PaginationList class="gap-1">
            <PaginationPrev @click="prevPage" variant="outline" class="h-6 w-6" />
            <PaginationNext @click="nextPage" variant="outline" class="h-6 w-6" />
          </PaginationList>
        </Pagination>
      </CardFooter>
    </Card>
  </form>
</template>

<script setup lang="ts">
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import {
  Pagination,
  PaginationList,
  PaginationNext,
  PaginationPrev
} from '@/components/ui/pagination';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { DockingResult, runDiffDock } from '@/lib/DiffDockRunner';
import { buildMultiModelSDF, downloadFile } from '@/lib/IO';
import { Molecule, runMolmim } from '@/lib/molmimApi';
import { smiles2sdf } from '@/lib/openbabel';
import { useField } from 'vee-validate';
import { computed, ref } from 'vue';

export interface Props {
  apiKey: string, 
  receptor: string
}

// Extending the Molecule interface to include an optional error property
export interface MoleculeWithStatus extends Molecule {
  error?: string; // Optional error property to describe issues
}


const props = withDefaults(defineProps<Props>(), {
  apiKey:undefined,
  receptor:undefined
})

const emit = defineEmits(['loading', 'update:proteinPdb']);

const { value: smileString, errorMessage: smileStringError } = useField<string>('smileString');
const molecules = ref<Array<MoleculeWithStatus>>([]);
const complexes = ref<Array<DockingResult>|undefined>([]);

const currentPage = ref(0);
const itemsPerPage = ref(5);

// Computed property to calculate the number of pages
const pageCount = computed(() => {
  return Math.ceil(molecules.value.length / itemsPerPage.value);
});

// Computed property to get the subset of molecules for the current page
const paginatedMolecules = computed(() => {
  const start = currentPage.value * itemsPerPage.value;
  const end = start + itemsPerPage.value;
  return molecules.value.slice(start, end);
});


const computeGlobalIndex = (index:number): number => {
  return currentPage.value * itemsPerPage.value + index;
};

// Methods to navigate pagination
const nextPage = () => {
  if (currentPage.value < pageCount.value - 1) {
    currentPage.value++;
  }
};

const prevPage = () => {
  if (currentPage.value > 0) {
    currentPage.value--;
  }
};

const onSubmit = async () => {    
  let fetchedMolecules: Molecule[]
  emit('loading', true);
  try{
     fetchedMolecules = await fetchMolMimResult(props.apiKey,smileString.value);
  } catch (error:any) {
        throw new Error(error)
  }  finally{
    emit('loading', false);
  }
  
  emit('loading', true);
  try{
      molecules.value = await convert2sdf(fetchedMolecules);
    } catch (error:any) {
        throw new Error(error)
  }  finally{
      emit('loading', false);
    }
  }

  const convert2sdf = async (fetchedMolecules:MoleculeWithStatus[]) => { 
    const promises = fetchedMolecules.map(async (mol) => {
      let error = undefined
      let sdf = undefined
      try{
        sdf = await smiles2sdf(mol.sample);
      } catch(error:any){
        error = error
      }
      return {
        error: error,
        ...(sdf ? { sdf } : {}), // Only add the sdf property if conversion was successful
        ...mol
      };
    });
    const results = await Promise.allSettled(promises);

    // Process results to handle both successes and errors
    const executionResults = results.map(result => {
      if (result.status === "fulfilled")
        return result.value; // The successful docking result

      return {
        sample: '',
        score: NaN,
        error: result.reason
      }; // Capture the error object
    });
    return executionResults;
  }

  const fetchMolMimResult = async (apiKey:string, smileString:string) => {    
    if (apiKey === undefined)
      throw new Error('API_KEY undefined.');

    let fetchedMolecules: Molecule[];
    try {
      fetchedMolecules = await runMolmim({ apiKey: apiKey, smiles: smileString });
      } catch (error: any) {
      throw new Error(error);
    }
    return fetchedMolecules;
  }


  const handleRunDiffDock = async () => {
    emit('loading', true);
    try {
      // Filter out undefined entries from the ligands array
      const ligands = molecules.value.map(mol => mol.sdf)                    

      if (ligands.length === 0)
        throw new Error('No valid SDF ligands available for docking');

      complexes.value = await runDiffDock({
        apiKey: props.apiKey,
        receptor: props.receptor,
        ligands: ligands
      });

    } catch (error: any) {
      throw new Error(`Error running DiffDock: ${error}`);
      } finally {
        emit('loading', false);
      }
  };



  const handleLigandDownload = (index:number) => {
    if(complexes.value === undefined)
      throw new Error('complexes is undefined. Check your code.')    
    const global_index = computeGlobalIndex(index)    
    const ligand_position = complexes.value[global_index].ligand_positions
    const multi_sdf = buildMultiModelSDF(ligand_position)
    downloadFile(`complex_${global_index}}.sdf`, multi_sdf )
  };
  </script>